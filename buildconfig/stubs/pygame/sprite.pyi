import sys
import types
from collections.abc import Callable, Iterable, Iterator
from typing import (
    Any,
    Generic,
    Optional,
    Protocol,
    SupportsFloat,
    TypeVar,
    Union,
)

# use typing_extensions for compatibility with older Python versions
if sys.version_info >= (3, 13):
    from warnings import deprecated
else:
    from typing_extensions import deprecated

if sys.version_info >= (3, 11):
    from typing import Self
else:
    from typing_extensions import Self

from pygame.mask import Mask
from pygame.rect import FRect, Rect
from pygame.surface import Surface
from pygame.typing import Point, RectLike

# define some useful protocols first, which sprite functions accept
# sprite functions don't need all sprite attributes to be present in the
# arguments passed, they only use a few which are marked in the below protocols
class _HasRect(Protocol):
    @property
    def rect(self) -> Optional[Union[FRect, Rect]]: ...

# image in addition to rect
class _HasImageAndRect(_HasRect, Protocol):
    @property
    def image(self) -> Optional[Surface]: ...

# mask in addition to rect
class _HasMaskAndRect(_HasRect, Protocol):
    mask: Mask

class Sprite:
    @property
    def image(self) -> Optional[Surface]: ...
    @image.setter
    def image(self, value: Optional[Surface]) -> None: ...
    @property
    def rect(self) -> Optional[Union[FRect, Rect]]: ...
    @rect.setter
    def rect(self, value: Optional[Union[FRect, Rect]]) -> None: ...
    @property
    def layer(self) -> int: ...
    @layer.setter
    def layer(self, value: int) -> None: ...
    def __init__(self, *groups: _GroupOrGroups[Any]) -> None: ...
    def add_internal(self, group: AbstractGroup[Any]) -> None: ...
    def remove_internal(self, group: AbstractGroup[Any]) -> None: ...
    def update(self, *args: Any, **kwargs: Any) -> None: ...
    def add(self, *groups: _GroupOrGroups[Any]) -> None: ...
    def remove(self, *groups: _GroupOrGroups[Any]) -> None: ...
    def kill(self) -> None: ...
    def alive(self) -> bool: ...
    def groups(self) -> list[AbstractGroup[Sprite]]: ...

class DirtySprite(Sprite):
    dirty: int
    blendmode: int
    source_rect: Union[FRect, Rect]
    visible: int
    _layer: int

_TSprite = TypeVar("_TSprite", bound=Sprite)
_TSprite2 = TypeVar("_TSprite2", bound=Sprite)
_TDirtySprite = TypeVar("_TDirtySprite", bound=DirtySprite)

_GroupOrGroups = Union[AbstractGroup[_TSprite], Iterable[_GroupOrGroups[_TSprite]]]
_SpriteOrSprites = Union[_TSprite, Iterable[_SpriteOrSprites[_TSprite]]]

class AbstractGroup(Generic[_TSprite]):
    spritedict: dict[_TSprite, Optional[Union[FRect, Rect]]]
    lostsprites: list[Union[FRect, Rect]]
    def __class_getitem__(cls, item: Any, /) -> types.GenericAlias: ...
    def __init__(self) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[_TSprite]: ...
    def __bool__(self) -> bool: ...
    def __contains__(self, item: Any) -> bool: ...
    def add_internal(self, sprite: _TSprite, layer: None = None) -> None: ...
    def remove_internal(self, sprite: _TSprite) -> None: ...
    def has_internal(self, sprite: _TSprite) -> bool: ...
    def copy(self) -> Self: ...
    def sprites(self) -> list[_TSprite]: ...
    def add(self, *sprites: _SpriteOrSprites[_TSprite]) -> None: ...
    def remove(self, *sprites: _SpriteOrSprites[_TSprite]) -> None: ...
    def has(self, *sprites: _SpriteOrSprites[_TSprite]) -> bool: ...
    def update(self, *args: Any, **kwargs: Any) -> None: ...
    def draw(
        self, surface: Surface, bgd: Optional[Surface] = None, special_flags: int = 0
    ) -> list[Union[FRect, Rect]]: ...
    def clear(
        self,
        surface: Surface,
        bgd: Union[Surface, Callable[[Surface, Union[FRect, Rect]], Any]],
    ) -> None: ...
    def empty(self) -> None: ...

class Group(AbstractGroup[_TSprite]):
    def __init__(self, *sprites: _SpriteOrSprites[_TSprite]) -> None: ...

# these are aliased in the code too
@deprecated("Use `pygame.sprite.Group` instead")
class RenderPlain(Group[_TSprite]): ...

@deprecated("Use `pygame.sprite.Group` instead")
class RenderClear(Group[_TSprite]): ...

class RenderUpdates(Group[_TSprite]): ...

@deprecated("Use `pygame.sprite.RenderUpdates` instead")
class OrderedUpdates(RenderUpdates[_TSprite]): ...

class LayeredUpdates(AbstractGroup[_TSprite]):
    def __init__(self, *sprites: _SpriteOrSprites[_TSprite], **kwargs: Any) -> None: ...
    def add(self, *sprites: _SpriteOrSprites[_TSprite], **kwargs: Any) -> None: ...
    def get_sprites_at(self, pos: Point) -> list[_TSprite]: ...
    def get_sprite(self, idx: int) -> _TSprite: ...
    def remove_sprites_of_layer(self, layer_nr: int) -> list[_TSprite]: ...
    def layers(self) -> list[int]: ...
    def change_layer(self, sprite: _TSprite, new_layer: int) -> None: ...
    def get_layer_of_sprite(self, sprite: _TSprite) -> int: ...
    def get_top_layer(self) -> int: ...
    def get_bottom_layer(self) -> int: ...
    def move_to_front(self, sprite: _TSprite) -> None: ...
    def move_to_back(self, sprite: _TSprite) -> None: ...
    def get_top_sprite(self) -> _TSprite: ...
    def get_sprites_from_layer(self, layer: int) -> list[_TSprite]: ...
    def switch_layer(self, layer1_nr: int, layer2_nr: int) -> None: ...

class LayeredDirty(LayeredUpdates[_TDirtySprite]):
    def draw(
        self,
        surface: Surface,
        bgd: Optional[Surface] = None,
        special_flags: Optional[int] = None,
    ) -> list[Union[FRect, Rect]]: ...
    # clear breaks Liskov substitution principle in code
    def clear(self, surface: Surface, bgd: Surface) -> None: ...  # type: ignore[override]
    def repaint_rect(self, screen_rect: RectLike) -> None: ...
    def set_clip(self, screen_rect: Optional[RectLike] = None) -> None: ...
    def get_clip(self) -> Union[FRect, Rect]: ...
    def set_timing_threshold(self, time_ms: SupportsFloat) -> None: ...
    @deprecated(
        "since 2.1.1. Use `pygame.sprite.LayeredDirty.set_timing_threshold` instead"
    )
    def set_timing_treshold(self, time_ms: SupportsFloat) -> None: ...

class GroupSingle(AbstractGroup[_TSprite]):
    sprite: Optional[_TSprite]
    def __init__(self, sprite: Optional[_TSprite] = None) -> None: ...

def collide_rect(left: _HasRect, right: _HasRect) -> bool: ...

class collide_rect_ratio:
    ratio: float
    def __init__(self, ratio: float) -> None: ...
    def __call__(self, left: _HasRect, right: _HasRect) -> bool: ...

# Must have rect attribute, may optionally have radius attribute
_SupportsCollideCircle = _HasRect

def collide_circle(
    left: _SupportsCollideCircle, right: _SupportsCollideCircle
) -> bool: ...

class collide_circle_ratio:
    ratio: float
    def __init__(self, ratio: float) -> None: ...
    def __call__(
        self, left: _SupportsCollideCircle, right: _SupportsCollideCircle
    ) -> bool: ...

# Argument to collide_mask must either have mask or have image attribute, in
# addition to mandatorily having a rect attribute
_SupportsCollideMask = Union[_HasImageAndRect, _HasMaskAndRect]

def collide_mask(
    left: _SupportsCollideMask, right: _SupportsCollideMask
) -> Optional[tuple[int, int]]: ...

_THasRect = TypeVar("_THasRect", bound=_HasRect)

def spritecollide(
    sprite: _THasRect,
    group: AbstractGroup[_TSprite],
    dokill: bool,
    collided: Optional[Callable[[_THasRect, _TSprite], Any]] = None,
) -> list[_TSprite]: ...
def groupcollide(
    groupa: AbstractGroup[_TSprite],
    groupb: AbstractGroup[_TSprite2],
    dokilla: bool,
    dokillb: bool,
    collided: Optional[Callable[[_TSprite, _TSprite2], Any]] = None,
) -> dict[_TSprite, list[_TSprite2]]: ...
def spritecollideany(
    sprite: _THasRect,
    group: AbstractGroup[_TSprite],
    collided: Optional[Callable[[_THasRect, _TSprite], Any]] = None,
) -> Optional[_TSprite]: ...
